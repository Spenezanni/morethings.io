[
	
		{
		  "title"      : "Gulp JS: como se tornar Expert em minutos",
		  "category"   : "",
		  "url"        : "http://morethings.io/javascript/gulpjs-como-se-tornar-expert-em-minutos",
		  "date"       : "2014-01-07 20:00:00 UTC",
		  "shortdate"  : "January 07, 2014",
		  "content"    : "Pra começar bem o ano, já tivemos o anúncio do Gulp JS. Gulp é um automatizador de tarefas escrito em JavaScript. Ele é uma alternativa para o, atualmente mais popular, GruntJS. Automatizar tarefas não é uma novidade. Algumas figurinhas já são bem conhecidas, como o ant para Java, rake para Ruby, entre outras. Mas todas seguem com um grande objetivo em comum: minimizar trabalho repetitivo. E pra manter a qualidade dos nossos projetos, não podemos deixar de estudar as opções que temos.Comparado com o Grunt, senti algumas vantagens interessantes, sendo mais simples e com menos configurações necessárias no código das tasks. O Gulpfile também aparenta ter um entendimento mais fácil, e consequentemente mais rápido.E no dia 3 de Janeiro, já tivemos o seguinte anúncio no Twitter oficial:A velocidade que está sendo feito os plugins é incrível. É um projeto muito recente e já tem muita contribuição da comunidade para conseguir avançar e nos ajudar cada vez mais em nossos projetos. Sem muito blá blá blá, vamos à pratica para ver sua simplicidade.Como base, segue abaixo um simples Gruntfile (script para Grunt), usado para rodar as seguintes tarefas:  Rodar os testes  JSHint nos arquivos JavaScript  Concat nos arquivos JavaScript  Minificar os arquivos  Rodar novamente sempre que os arquivos forem alterados (watch)module.exports = function(grunt) {  grunt.initConfig({    pkg: grunt.file.readJSON(&#39;package.json&#39;),    concat: {      options: {        separator: &#39;;&#39;      },      dist: {        src: [&#39;src/**/*.js&#39;],        dest: &#39;dist/&lt;%= pkg.name %&gt;.js&#39;      }    },    uglify: {      options: {        banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;dd-mm-yyyy&quot;) %&gt; */\n&#39;      },      dist: {        files: {          &#39;dist/&lt;%= pkg.name %&gt;.min.js&#39;: [&#39;&lt;%= concat.dist.dest %&gt;&#39;]        }      }    },    qunit: {      files: [&#39;test/**/*.html&#39;]    },    jshint: {      files: [&#39;gruntfile.js&#39;, &#39;src/**/*.js&#39;, &#39;test/**/*.js&#39;],      options: {        // options here to override JSHint defaults        globals: {          jQuery: true,          console: true,          module: true,          document: true        }      }    },    watch: {      files: [&#39;&lt;%= jshint.files %&gt;&#39;],      tasks: [&#39;jshint&#39;, &#39;qunit&#39;]    }  });  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-qunit&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);  grunt.registerTask(&#39;test&#39;, [&#39;jshint&#39;, &#39;qunit&#39;]);  grunt.registerTask(&#39;default&#39;, [&#39;jshint&#39;, &#39;qunit&#39;, &#39;concat&#39;, &#39;uglify&#39;]);};Segue abaixo um exemplo do gulpfile.js, similar ao Gruntfile acima, escrito para o GulpJS :)var gulp = require(&#39;gulp&#39;);var pkg = require(&#39;./package.json&#39;);var concat = require(&#39;gulp-concat&#39;);var minify = require(&#39;gulp-minify&#39;);var jshint = require(&#39;gulp-jshint&#39;);var spawn = require(&#39;child_process&#39;).spawn;var scriptFiles = &#39;./src/**/*.js&#39;;gulp.task(&#39;compile&#39;, function(){  // concat all scripts, minify, and output  gulp.src(scriptFiles)    .pipe(concat({fileName: pkg.name+&quot;.js&quot;})    .pipe(minify())    .pipe(gulp.dest(&#39;./dist/&#39;));});gulp.task(&#39;test&#39;, function(){  // lint our scripts  gulp.src(scriptFiles).pipe(jshint());Quais as diferenças?  Você utiliza o padrão do Gulp para fazer as tarefas básicas  Plugins são simples e fazem apenas uma coisa. A maioria são apenas uma função com 20 linhas em média  As tarefas são executadas de forma encadeada  O código é bem menor e a curva de aprendizado também :)  O Gulp não faz nada, apenas fornece um sistema básico de tarefasLearning…Como aprender Grup? São 5 tarefas básicas que você precisa entender. São elas:gulp.task(name, fn)Isto registra uma função com um nome.Você pode opcionalmente especificar algumas dependências se outras tarefas precisam rodar antes.gulp.run(tasks…)Roda todas as tarefas de forma encadeadagulp.watch(glob, fn)Roda a função quando o arquivo tiver alterações(*) Incluido no core para simplificargulp.src(glob)Os arquivos que serão lidos no fluxo, e inicia a emissão do arquivo correspondente, podendo ser usado em outros fluxos.gulp.dest(folder)Isto irá retornar o resultado do fluxo, e será salvo no destino (similar ao writeFile() do FileSystem, para quem já está acostumado com Node).Pois é. Estes são os 5 métodos padrões do Gulp. E todos eles são usados no código de exemplo acima para facilitar o entendimento.Parabéns!Como a própria documentação diz, você agora tornou-se expert em Gulp! :)"
		} ,
	
		{
		  "title"      : "Novas collections do EcmaScript 6",
		  "category"   : "",
		  "url"        : "http://morethings.io/javascript/novas-collections-do-ecmascript-6",
		  "date"       : "2013-12-19 10:00:00 UTC",
		  "shortdate"  : "December 19, 2013",
		  "content"    : "Para quem estava no Front in Recife, e acompanhou a minha palestra junto com Guilherme Farias ja teve um spoiler do post, visto que apresentamos la um pouco sobre as novas collections, bem como outras novidades do ECMAScript 6.O que são collections?Em toda a história do JavaScript, houve apenas um tipo de collection representado pelo Array. Em outras linguagens como Python, Ruby e Java, já existem outras collections, e com a especificação do ECMAScript 6, também poderemos usá-las. Os novos tipos permitem o armazenamento melhor e mais eficiente de dados.SetsSets são listas ordenadas de valores que não permite valores duplicados. Normalmente você não acessa itens que foram setados, como normalmente fazemos com Arrays, ao invés disso, é mais comum verificar o conjunto para ver se um valor está presente.Permite-se adicionar valores usando o método add() e verificar quantos itens estão no set usando size().var items = new Set();items.add(5);items.add(&quot;5&quot;);console.log(items.size()); // 2items.add(5); // ja existe, sera ignoradoconsole.log(items.size()); // 2Pode-se verificar se algum item está no set usando o método has(). Para remover algum valor, basta usar o método remove().console.log(items.has(5)); // trueitems.delete(5)console.log(items.has(5)); // falseMapsÉ bem parecido com os sets, mas a ideia básica do map é que possui uma chave única, que você pode setar ou verificar a qualquer momento usando esta chave. Em JavaScript, os desenvolvedores tradicionalmente usam objetos regulares como Maps. Inclusive o próprio JSON é baseado neste conceito que representa pares de chave/valor.var map = new Map();map.set(&quot;cor&quot;, &quot;verde&quot;);console.log(map.has(&quot;cor&quot;));   // trueconsole.log(map.get(&quot;cor&quot;));   // &quot;verde&quot;console.log(map.size());       // 1map.delete(&quot;cor&quot;);console.log(map.has(&quot;cor&quot;));   // falseconsole.log(map.get(&quot;cor&quot;));   // undefinedconsole.log(map.size());       // 0WeakMapsBem parecido com os maps, os weakmaps também são baseados em chave/valor. Porém, a chave não pode ser um tipo primitivo (String, por exemplo). Ao invés disso, a chave deve ser um objeto. Isto pode parecer estranho, mas isto é bastante útil em algumas situações.var map = new WeakMap(),    element = document.querySelector(&quot;.element&quot;);map.set(element, &quot;valor qualquer&quot;);var value = map.get(element);console.log(value); // &quot;valor qualquer&quot;element.parentNode.removeChild(element);element = null;value = map.get(element);console.log(value); // undefined"
		} 
	
]