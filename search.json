[
	
		{
		  "title"      : "Como configurar um servidor node.js para produção",
		  "category"   : "",
		  "url"        : "http://www.morethings.io/javascript/node/como-configurar-um-servidor-nodejs-para-producao",
		  "date"       : "2014-01-16 20:00:00 UTC",
		  "shortdate"  : "January 16, 2014",
		  "content"    : "Neste post, estou assumindo que você já possui sua VPS instalada e configurada com o Ubuntu Server. Optei pelo Ubuntu, por ser uma distribuição super simples de configurar. Caso você não possua, aqui vão algumas opções:  Amazon EC2  Linode  WebbyNode  Digital OceanApós o jabá gratuito, o primeiro passo, é você facilitar futuros acessos a máquina, guardando sua chave pública (~/.ssh/id_rsa.pub). Se você não sabe como gerar sua chave, siga este tutorial. O motivo deste procedimento é para você não precisar digitar sua senha toda as vezes que acessar a VPS.SSH keySe você utiliza Mac, aqui vai uma dica super simples para copiar sua chave:cat ~/.ssh/id_rsa.pub | pbcopyCom este comando, sua chave já estará no seu clipboard para colar no servidor. Com sua chave em mãos, vamos nos conectar à vps e executar os seguintes comandos:ssh usuario@ip-de-sua-vps # Ele vai solicitar sua senha desta vez.cd ~/.ssh # Caso o diretório .ssh não exista, você deve criá-lo: mkdir ~/.sshvi authorized_keysCaso o arquivo não exista, digite touch authorized_keys. Em alguns casos você precisará utilizar sudo. Então, sudo touch authorized_keys e sudo vi authorized_keys.Com o arquivo aberto no terminal, digite a tecla i para entrar em modo de edição no vi. Com o modo de edição ativado, cole sua chave que já deve estar no seu clipboard. (cmd + v para macs) e (control + v) para Windows/Linux. Com sua chave colada, aperte esc para voltar ao modo de leitura e em seguida x para salvar e fechar ao mesmo tempo.Pronto, ssh key copiada! Caso você tenha criado o arquivo authorized_keys, você vai precisar executar este comando para que o que fizemos tenha feito:sudo chmod 444 ~/.ssh/authorized_keysEsta forma de copiar a chave é bem manual, mas serve como aprendizado.Outra forma muito útil de copiar sua chave é utilizando ssh-copy-id. Se você utiliza Ubuntu por exemplo é só utilizar o comando. Se você é usuário Mac, você pode instalar através do brew install ssh-copy-id. Para utilizar é muito simples:ssh-copy-id user@hostname.example.comAgora, da próxima vez que você acessar sua VPS ssh user@ip-de-sua-vps, não haverá necessidade de digitar sua senha.Seguindo.. GIT!Para nosso deploy, nós utilizaremos o GIT e o forever. Para isso, precisamos instalar o git na VPS. Para verificar se você já possui o git instalado, digite which git. Se você receber a mensagem “git not found”, vamos instalá-lo através do seguinte comando:sudo apt-get install gitProvavelmente a instalação pedirá para você apertar Y para concordar em baixar os arquivos.Com o GIT instalado, nos resta começar a brincar de instalar o NODE e logo menos, o forever para manter sua aplicação rodando em background.Instalando o NodePara instalar o node, vamos utilizar o apt-get, porém, os pacotes nem sempre estão atualizados como deveriam, então, para garantir que seja instalada a versão mais nova do node, vamos informar ao apt-get que desejamos um repositório específico para baixar o node:sudo add-apt-repository ppa:chris-lea/node.jssudo apt-get updatesudo apt-get install nodejsCom o node instalado, vamos testar se funcionou digitando node --version. Pronto, você já deve estar com o node instalado e consequentemente o npm, já que o mesmo vem “built-in” já faz algum tempo.Vamos ao exemplo! Finalmente, node!Navegue até a pasta de seu usuário, Vamos clonar uma aplicação Express já existente para facilitar nosso trabalho.cd ~git clone https://github.com/djalmaaraujo/express-js-example-blogcd express-js-example-blogSe você tentar rodar node app.js, você vai receber alguns erros, uma vez que precisamos instalar as dependências. Para isso, vamos utilizar o ```npm install``. Depois de algum tempo e muito output, o final se parecerá com isso:......express@3.4.7 node_modules/express├── methods@0.1.0├── merge-descriptors@0.0.1├── cookie-signature@1.0.1doctype html├── range-parser@0.0.4├── fresh@0.2.0├── debug@0.7.4├── buffer-crc32@0.2.1├── cookie@0.1.0├── mkdirp@0.3.5├── send@0.1.4 (mime@1.2.11)├── commander@1.3.2 (keypress@0.1.0)└── connect@2.12.0 (uid2@0.0.3, pause@0.0.1, qs@0.6.6, bytes@0.2.1, raw-body@1.1.2, batch@0.5.0, negotiator@0.3.0, multiparty@2.2.0)Pronto! Estamos prontos para rodar nossa primeira aplicação node em nossa VPS. Para isso, digite node app.js ou apenas node app. Com isso você receberá a seguinte mensagem:Express server listening on port 3000Agora, você deve acessar sua VPS no browser, http://ip-de-sua-vps:3000. Você verá a tela do express inicial:ExpressWelcome to ExpressE agora?Perfeito! Agora nós temos nossa aplicação rodando e já podemos efetuar testes. Mas ninguém gosta de acessar sites na porta 3000, correto? Para configurar nossa porta 80, nós faremos mais algumas coisas.Por padrão, o Ubuntu server vem com porta 80 bloqueada em seu firewall e além disso, para não ter necessidade de ficar “cascavilhando” e brigando com firewall e etc, vamos manter nossa aplicação rodando na porta 3000 e redirecionar a porta 80. Assim, quando os usuários acessarem seu app, a porta 80 será redirecionada para a porta 3000 em background.Não, seu browser não será redirecionado para :3000Para isso vamos primeiro checar se o “ip forwarding” está ativado na máquina. cat /proc/sys/net/ipv4/ip_forward vai te dizer se está ativado ou não. Caso você receba 0, para habilitar utilize as seguintes instruções:sudo vi /etc/sysctl.confnet.ipv4.ip_forward # Descomente esta linha no arquivo aberto. Salve e feche o arquivo.sudo sysctl -p /etc/sysctl.conf # Para ativar as modificações feitas no arquivo.cat /proc/sys/net/ipv4/ip_forward # Para verificar se agora está ativado.Com o “port forwarding” ativado, agora vamos ativar nosso redirecionamento da porta 80 para a porta 3000, utilizando iptables.sudo iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 3000Como dito acima, por padrão a porta 80 é bloqueada no firewall, então vamos permitir conexões através desta porta:sudo iptables -A INPUT -p tcp -m tcp --sport 80 -j ACCEPTsudo iptables -A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPTReiniciando a aplicaçãoVá até sua aplicação, inicie a mesma node app, e verifique agora no seu browser, que você pode acessar sua máquina através da porta 80. http://ip-de-sua-maquina. O output da aplicação continuará dizendo listening on port 3000, mas agora sua porta 80 está sendo redirecionada para a 3000.Mais um passo para a vitória. Colocando a aplicação para rodar em background com foreverVamos começar instalado o forever, através do npm.[sudo] npm install forever -gPara utilizar o forever é extremamente simples, apenas saiba o path de sua aplicação e digite o seguinte comando:forever start /home/seuusuario/express-js-example-blog/app.jsCom isso, você terá o seguinte output:warn:    --minUptime not set. Defaulting to: 1000mswarn:    --spinSleepTime not set. Your script will exit if it does not stay up for at least 1000msinfo:    Forever processing file: app.jsVocê percebeu que agora, seu console ficou livre para efetuar outras operações. Isso acontece devido ao forever colocar o processo do node em background.Aqui vão algumas dicas para você interagir mais com o forever:  forever list Lista todas as suas aplicações iniciadas com o forever.  tail -f /path/para/o/log/fornecido.log Você pode verificar o log de sua aplicação em tempo real.  forever stopall Para todas as aplicações  forever stop ID Para uma aplicação específica. Para conseguir o id, digite forever list.Mais detalhes, acesse: https://github.com/nodejitsu/foreverUp and running!Seguindo todos estes passos, você terá sua VPS configurada para rodar suas aplicações node sem se preocupar em utilizar hosts de terceiros.Existem diversas formas de se fazer setup de aplicações, e esta nem é a melhor, nem a pior, mas funciona. Se você estiver trabalhando em um projeto pequeno e que você não está preocupado em ter acesso root a máquina, eu recomendo fortemente que você utilize o Heroku para deploy de suas aplicações node/ruby/whatever.Para o setup no heroku, você pode seguir este simples “Getting started”: https://devcenter.heroku.com/articles/getting-started-with-nodejs, mas isso é assunto para outro post.Comentem, reclamem, corrijam! Até mais!"
		} ,
	
		{
		  "title"      : "Gulp JS: como se tornar Expert em minutos",
		  "category"   : "",
		  "url"        : "http://www.morethings.io/javascript/gulpjs-como-se-tornar-expert-em-minutos",
		  "date"       : "2014-01-07 20:00:00 UTC",
		  "shortdate"  : "January 07, 2014",
		  "content"    : "Pra começar bem o ano, já tivemos o anúncio do Gulp JS. Gulp é um automatizador de tarefas escrito em JavaScript. Ele é uma alternativa para o, atualmente mais popular, GruntJS. Automatizar tarefas não é uma novidade. Algumas figurinhas já são bem conhecidas, como o ant para Java, rake para Ruby, entre outras. Mas todas seguem com um grande objetivo em comum: minimizar trabalho repetitivo. E pra manter a qualidade dos nossos projetos, não podemos deixar de estudar as opções que temos.Comparado com o Grunt, senti algumas vantagens interessantes, sendo mais simples e com menos configurações necessárias no código das tasks. O Gulpfile também aparenta ter um entendimento mais fácil, e consequentemente mais rápido.E no dia 3 de Janeiro, já tivemos o seguinte anúncio no Twitter oficial:A velocidade que está sendo feito os plugins é incrível. É um projeto muito recente e já tem muita contribuição da comunidade para conseguir avançar e nos ajudar cada vez mais em nossos projetos. Sem muito blá blá blá, vamos à pratica para ver sua simplicidade.Como base, segue abaixo um simples Gruntfile (script para Grunt), usado para rodar as seguintes tarefas:  Rodar os testes  JSHint nos arquivos JavaScript  Concat nos arquivos JavaScript  Minificar os arquivos  Rodar novamente sempre que os arquivos forem alterados (watch)module.exports = function(grunt) {  grunt.initConfig({    pkg: grunt.file.readJSON(&#39;package.json&#39;),    concat: {      options: {        separator: &#39;;&#39;      },      dist: {        src: [&#39;src/**/*.js&#39;],        dest: &#39;dist/&lt;%= pkg.name %&gt;.js&#39;      }    },    uglify: {      options: {        banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;dd-mm-yyyy&quot;) %&gt; */\n&#39;      },      dist: {        files: {          &#39;dist/&lt;%= pkg.name %&gt;.min.js&#39;: [&#39;&lt;%= concat.dist.dest %&gt;&#39;]        }      }    },    qunit: {      files: [&#39;test/**/*.html&#39;]    },    jshint: {      files: [&#39;gruntfile.js&#39;, &#39;src/**/*.js&#39;, &#39;test/**/*.js&#39;],      options: {        // options here to override JSHint defaults        globals: {          jQuery: true,          console: true,          module: true,          document: true        }      }    },    watch: {      files: [&#39;&lt;%= jshint.files %&gt;&#39;],      tasks: [&#39;jshint&#39;, &#39;qunit&#39;]    }  });  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-qunit&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);  grunt.registerTask(&#39;test&#39;, [&#39;jshint&#39;, &#39;qunit&#39;]);  grunt.registerTask(&#39;default&#39;, [&#39;jshint&#39;, &#39;qunit&#39;, &#39;concat&#39;, &#39;uglify&#39;]);};Segue abaixo um exemplo do gulpfile.js, similar ao Gruntfile acima, escrito para o GulpJS :)var gulp = require(&#39;gulp&#39;);var pkg = require(&#39;./package.json&#39;);var concat = require(&#39;gulp-concat&#39;);var minify = require(&#39;gulp-minify&#39;);var jshint = require(&#39;gulp-jshint&#39;);var spawn = require(&#39;child_process&#39;).spawn;var scriptFiles = &#39;./src/**/*.js&#39;;gulp.task(&#39;compile&#39;, function(){  // concat all scripts, minify, and output  gulp.src(scriptFiles)    .pipe(concat({fileName: pkg.name+&quot;.js&quot;})    .pipe(minify())    .pipe(gulp.dest(&#39;./dist/&#39;));});gulp.task(&#39;test&#39;, function(){  // lint our scripts  gulp.src(scriptFiles).pipe(jshint());Quais as diferenças?  Você utiliza o padrão do Gulp para fazer as tarefas básicas  Plugins são simples e fazem apenas uma coisa. A maioria são apenas uma função com 20 linhas em média  As tarefas são executadas de forma encadeada  O código é bem menor e a curva de aprendizado também :)  O Gulp não faz nada, apenas fornece um sistema básico de tarefasLearning…Como aprender Gulp? São 5 tarefas básicas que você precisa entender. São elas:gulp.task(name, fn)Isto registra uma função com um nome.Você pode opcionalmente especificar algumas dependências se outras tarefas precisam rodar antes.gulp.run(tasks…)Roda todas as tarefas de forma encadeadagulp.watch(glob, fn)Roda a função quando o arquivo tiver alterações(*) Incluido no core para simplificargulp.src(glob)Os arquivos que serão lidos no fluxo, e inicia a emissão do arquivo correspondente, podendo ser usado em outros fluxos.gulp.dest(folder)Isto irá retornar o resultado do fluxo, e será salvo no destino (similar ao writeFile() do FileSystem, para quem já está acostumado com Node).Pois é. Estes são os 5 métodos padrões do Gulp. E todos eles são usados no código de exemplo acima para facilitar o entendimento.Parabéns!Como a própria documentação diz, você agora tornou-se expert em Gulp! :)"
		} ,
	
		{
		  "title"      : "Novas collections do EcmaScript 6",
		  "category"   : "",
		  "url"        : "http://www.morethings.io/javascript/novas-collections-do-ecmascript-6",
		  "date"       : "2013-12-19 10:00:00 UTC",
		  "shortdate"  : "December 19, 2013",
		  "content"    : "Para quem estava no Front in Recife, e acompanhou a minha palestra junto com Guilherme Farias ja teve um spoiler do post, visto que apresentamos la um pouco sobre as novas collections, bem como outras novidades do ECMAScript 6.O que são collections?Em toda a história do JavaScript, houve apenas um tipo de collection representado pelo Array. Em outras linguagens como Python, Ruby e Java, já existem outras collections, e com a especificação do ECMAScript 6, também poderemos usá-las. Os novos tipos permitem o armazenamento melhor e mais eficiente de dados.SetsSets são listas ordenadas de valores que não permite valores duplicados. Normalmente você não acessa itens que foram setados, como normalmente fazemos com Arrays, ao invés disso, é mais comum verificar o conjunto para ver se um valor está presente.Permite-se adicionar valores usando o método add() e verificar quantos itens estão no set usando size().var items = new Set();items.add(5);items.add(&quot;5&quot;);console.log(items.size()); // 2items.add(5); // ja existe, sera ignoradoconsole.log(items.size()); // 2Pode-se verificar se algum item está no set usando o método has(). Para remover algum valor, basta usar o método remove().console.log(items.has(5)); // trueitems.delete(5)console.log(items.has(5)); // falseMapsÉ bem parecido com os sets, mas a ideia básica do map é que possui uma chave única, que você pode setar ou verificar a qualquer momento usando esta chave. Em JavaScript, os desenvolvedores tradicionalmente usam objetos regulares como Maps. Inclusive o próprio JSON é baseado neste conceito que representa pares de chave/valor.var map = new Map();map.set(&quot;cor&quot;, &quot;verde&quot;);console.log(map.has(&quot;cor&quot;));   // trueconsole.log(map.get(&quot;cor&quot;));   // &quot;verde&quot;console.log(map.size());       // 1map.delete(&quot;cor&quot;);console.log(map.has(&quot;cor&quot;));   // falseconsole.log(map.get(&quot;cor&quot;));   // undefinedconsole.log(map.size());       // 0WeakMapsBem parecido com os maps, os weakmaps também são baseados em chave/valor. Porém, a chave não pode ser um tipo primitivo (String, por exemplo). Ao invés disso, a chave deve ser um objeto. Isto pode parecer estranho, mas isto é bastante útil em algumas situações.var map = new WeakMap(),    element = document.querySelector(&quot;.element&quot;);map.set(element, &quot;valor qualquer&quot;);var value = map.get(element);console.log(value); // &quot;valor qualquer&quot;element.parentNode.removeChild(element);element = null;value = map.get(element);console.log(value); // undefined"
		} 
	
]